public class FileProcessor
{
    private readonly Config _config;
    private readonly Logger _logger;
    private readonly Variables _vars;

    public FileProcessor(Config config, Logger logger, Variables vars)
    {
        _config = config;
        _logger = logger;
        _vars = vars;
    }

    public void Execute()
    {
        bool anyNewProcessed = false;

        switch (_config.ActionType)
        {
            case "Move":
                anyNewProcessed = ProcessFiles(isMove: true);
                break;
            case "Copy":
                anyNewProcessed = ProcessFiles(isMove: false);
                break;
            case "Zip":
                anyNewProcessed = ZipFiles();
                break;
            default:
                throw new Exception($"Unknown ActionType: {_config.ActionType}");
        }

        // If this is Sequence 1 and nothing new was processed
        if (_config.Sequence == 1 && !anyNewProcessed)
        {
            try
            {
                _vars["User::HasFiles"].Value = false;
                _logger.LogInfo(_config, "AllDuplicates", "All files were previously processed; archived and skipping later sequences.");
            }
            catch (Exception ex)
            {
                _logger.LogError("SetHasFilesFalse", ex.Message);
            }
        }
    }

    public static string[] GetFilesByPatternAndDate(string folder, string pattern, DateTime date)
    {
        return Directory.GetFiles(folder, pattern)
            .Where(file => File.GetLastWriteTime(file).Year == date.Year &&
                           File.GetLastWriteTime(file).Month == date.Month)
            .ToArray();
    }

    private bool ProcessFiles(bool isMove)
    {
        bool processedAnyNew = false;

        try
        {
            ValidateDirectories(_config.SourceFolder, _config.DestinationFolder);
            EnsureDirectory(_config.ArchiveFolder);

            var files = GetMatchingFiles();

            foreach (var file in files)
            {
                var fileName = Path.GetFileName(file);
                long fileSize = new FileInfo(file).Length;

                // Duplicate → move to ArchiveFolder and skip normal action
                if (IsAlreadyProcessed(fileName, _config.MappingID, fileSize))
                {
                    MoveToArchiveSafely(file, fileName);
                    continue;
                }

                try
                {
                    var dest = Path.Combine(_config.DestinationFolder, fileName);
                    if (isMove)
                    {
                        if (File.Exists(dest)) File.Delete(dest);
                        File.Move(file, dest);
                    }
                    else
                    {
                        File.Copy(file, dest, true);
                    }

                    processedAnyNew = true;
                    _logger.LogSuccess(_config, fileName, isMove ? "Moved" : "Copied", fileSize);
                }
                catch (Exception ex)
                {
                    _logger.LogError(fileName, ex.Message, fileSize);
                }
            }
        }
        catch (Exception ex)
        {
            _logger.LogError("ProcessFiles", ex.Message);
        }

        return processedAnyNew;
    }

    private bool ZipFiles()
    {
        bool zippedAnything = false;

        try
        {
            ValidateDirectories(_config.SourceFolder, _config.DestinationFolder);
            EnsureDirectory(_config.ArchiveFolder);

            var files = GetMatchingFiles();

            // Split: non-duplicates to zip, duplicates to archive
            var toZip = files.Where(f =>
            {
                var fi = new FileInfo(f);
                return !IsAlreadyProcessed(fi.Name, _config.MappingID, fi.Length);
            }).ToArray();

            var duplicates = files.Except(toZip).ToArray();

            // Archive duplicates
            foreach (var dup in duplicates)
            {
                MoveToArchiveSafely(dup, Path.GetFileName(dup));
            }

            if (toZip.Length == 0)
            {
                _logger.LogInfo(_config, "Zip", "No new files to zip (all duplicates archived).");
                return false; // don’t create empty zip
            }

            var zipPath = Path.Combine(_config.DestinationFolder, $"{_config.ZipName}_{DateTime.Now:yyyyMM}.zip");
            var mode = File.Exists(zipPath) ? ZipArchiveMode.Update : ZipArchiveMode.Create;

            using (var archive = ZipFile.Open(zipPath, mode))
            {
                foreach (var file in toZip)
                {
                    var fileName = Path.GetFileName(file);
                    try
                    {
                        bool entryExists = archive.Entries.Any(e =>
                            string.Equals(e.Name, fileName, StringComparison.OrdinalIgnoreCase));

                        if (!entryExists)
                        {
                            archive.CreateEntryFromFile(file, fileName);
                            zippedAnything = true;
                            _logger.LogSuccess(_config, fileName, "Compressed", new FileInfo(file).Length);
                        }
                        else
                        {
                            _logger.LogInfo(_config, fileName, "Skipped (already in zip).");
                        }
                    }
                    catch (Exception ex)
                    {
                        _logger.LogError($"Zip:{fileName}", ex.Message, new FileInfo(file).Length);
                    }
                }
            }
        }
        catch (Exception ex)
        {
            _logger.LogError("ZipFiles", ex.Message);
        }

        return zippedAnything;
    }

    private void MoveToArchiveSafely(string sourcePath, string fileName)
    {
        try
        {
            if (string.IsNullOrWhiteSpace(_config.ArchiveFolder))
            {
                _logger.LogError("ArchiveFolder", "ArchiveFolder is empty; cannot move duplicate to archive.");
                return;
            }

            EnsureDirectory(_config.ArchiveFolder);

            var dest = Path.Combine(_config.ArchiveFolder, fileName);

            if (File.Exists(sourcePath))
            {
                if (File.Exists(dest)) File.Delete(dest);
                File.Move(sourcePath, dest);
            }

            _logger.LogInfo(_config, fileName, $"Duplicate detected; moved to archive '{_config.ArchiveFolder}'.");
        }
        catch (Exception ex)
        {
            _logger.LogError($"Archive:{fileName}", ex.Message);
        }
    }

    private string[] GetMatchingFiles()
    {
        var exclusions = _config.ExclusionList.Split(new char[] { ',' }, StringSplitOptions.RemoveEmptyEntries);
        return Directory.GetFiles(_config.SourceFolder, _config.FilePattern)
            .Where(file =>
            {
                var name = Path.GetFileName(file);
                return !exclusions.Any(ex => name.IndexOf(ex.Trim(), StringComparison.OrdinalIgnoreCase) >= 0);
            })
            .ToArray();
    }

    private bool IsAlreadyProcessed(string fileName, int mappingID, long fileSize)
    {
        var connStr = _vars["User::CM_OLEDB_ClaimsStage"].Value.ToString();

        using (var conn = new SqlConnection(connStr))
        {
            conn.Open();
            string query = @"SELECT COUNT(*) FROM MoveIt.FileTransferLog 
                             WHERE FileName = @FileName 
                               AND MappingID = @MappingID 
                               AND FileSize = @FileSize
                               AND Status = 'Success'";
            using (SqlCommand cmd = new SqlCommand(query, conn))
            {
                cmd.Parameters.AddWithValue("@FileName", fileName);
                cmd.Parameters.AddWithValue("@MappingID", mappingID);
                cmd.Parameters.AddWithValue("@FileSize", fileSize);
                return (int)cmd.ExecuteScalar() > 0;
            }
        }
    }

    private void ValidateDirectories(params string[] folders)
    {
        foreach (var folder in folders)
        {
            if (!Directory.Exists(folder))
                throw new DirectoryNotFoundException($"Folder not found: {folder}");
        }
    }

    private void EnsureDirectory(string folder)
    {
        if (!string.IsNullOrWhiteSpace(folder) && !Directory.Exists(folder))
        {
            Directory.CreateDirectory(folder);
        }
    }
}



Logger.cs

public class Logger
{
    private readonly Variables _vars;

    public Logger(Variables vars)
    {
        _vars = vars;
    }

    public void LogInfo(Config config, string fileName, string message, long fileSize = 0) =>
        LogOperation(config, fileName, "Info", message, fileSize);

    public void LogSuccess(Config config, string fileName, string action, long fileSize = 0) =>
        LogOperation(config, fileName, "Success", $"File {action} successfully.", fileSize);

    public void LogError(string context, string message, long fileSize = 0) =>
        LogOperation(null, context, "Failure", message, fileSize);

    private void LogOperation(Config config, string fileName, string status, string message, long fileSize = 0)
    {
        try
        {
            int mappingID = config?.MappingID ?? -1;
            string actionType = config?.ActionType ?? "Unknown";
            Console.WriteLine($"[LOG] MappingID: {mappingID}, File: {fileName}, Size: {fileSize}, Status: {status}, Message: {message}");
            WriteLogToDatabase(mappingID, actionType, fileName, status, message, fileSize);
        }
        catch (Exception ex)
        {
            Console.WriteLine($"Logging failed: {ex.Message}");
        }
    }

    private void WriteLogToDatabase(int mappingID, string actionType, string fileName, string status, string message, long fileSize)
    {
        var connStr = _vars["User::CM_OLEDB_ClaimsStage"].Value.ToString();

        using (var conn = new SqlConnection(connStr))
        {
            conn.Open();
            string query = @"INSERT INTO MoveIt.FileTransferLog 
                            (MappingID, ActionType, FileName, FileSize, Status, LogMessage, ProcessedAt)
                            VALUES (@MappingID, @ActionType, @FileName, @FileSize, @Status, @Message, GETDATE())";
            using (SqlCommand cmd = new SqlCommand(query, conn))
            {
                cmd.Parameters.AddWithValue("@MappingID", mappingID);
                cmd.Parameters.AddWithValue("@ActionType", actionType);
                cmd.Parameters.AddWithValue("@FileName", fileName);
                cmd.Parameters.AddWithValue("@FileSize", fileSize);
                cmd.Parameters.AddWithValue("@Status", status);
                cmd.Parameters.AddWithValue("@Message", message);
                cmd.ExecuteNonQuery();
            }
        }
    }
}


ALTER TABLE MoveIt.FileTransferLog 
ADD FileSize BIGINT NULL;


private bool ZipFiles()
{
    bool zippedAnything = false;

    try
    {
        ValidateDirectories(_config.SourceFolder, _config.DestinationFolder);
        EnsureDirectory(_config.ArchiveFolder);

        var files = GetMatchingFiles();

        // Split: non-duplicates to zip, duplicates to archive
        var toZip = files.Where(f =>
        {
            var fi = new FileInfo(f);
            return !IsAlreadyProcessed(fi.Name, _config.MappingID, fi.Length);
        }).ToArray();

        var duplicates = files.Except(toZip).ToArray();

        // Archive duplicates
        foreach (var dup in duplicates)
        {
            MoveToArchiveSafely(dup, Path.GetFileName(dup));
        }

        if (toZip.Length == 0)
        {
            _logger.LogInfo(_config, "Zip", "No new files to zip (all duplicates archived).");
            return false; // don’t create/append empty zip
        }

        var zipPath = Path.Combine(_config.DestinationFolder, $"{_config.ZipName}_{DateTime.Now:yyyyMM}.zip");

        using (var zipToOpen = new FileStream(zipPath, FileMode.OpenOrCreate))
        using (var archive = new ZipArchive(zipToOpen, ZipArchiveMode.Update))
        {
            foreach (var file in toZip)
            {
                var fileName = Path.GetFileName(file);
                try
                {
                    bool entryExists = archive.Entries.Any(e =>
                        string.Equals(e.Name, fileName, StringComparison.OrdinalIgnoreCase));

                    if (!entryExists)
                    {
                        archive.CreateEntryFromFile(file, fileName);
                        zippedAnything = true;
                        _logger.LogSuccess(_config, fileName, "Appended to Zip", new FileInfo(file).Length);
                    }
                    else
                    {
                        _logger.LogInfo(_config, fileName, "Skipped (already in zip).");
                    }
                }
                catch (Exception ex)
                {
                    _logger.LogError($"Zip:{fileName}", ex.Message, new FileInfo(file).Length);
                }
            }
        }
    }
    catch (Exception ex)
    {
        _logger.LogError("ZipFiles", ex.Message);
    }

    return zippedAnything;
}

